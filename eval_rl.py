"""
eval_rl.py

This module evaluates a pre-trained RL agent on a long synthetic stock price path
generated by a Geometric Brownian Motion (GBM) simulation. It compares the RL decisions
with the PDE-based optimal decisions and generates visualizations.
"""

import numpy as np
import matplotlib.pyplot as plt
import torch
from environment import ConvertibleBondEnvTF
from tf_engine import TsiveriotisFernandesEngine
from rl_agent import PolicyGradientAgent


def generate_gbm_stock_path(S0, mu, sigma, T, num_steps):
    """
    Generates a stock price path using Geometric Brownian Motion.
    Returns both the stock path and corresponding time points.
    """
    dt = T / (num_steps - 1)
    times = np.linspace(0, T, num_steps)
    stock_path = np.zeros(num_steps)
    stock_path[0] = S0
    for t in range(1, num_steps):
        Z = np.random.normal()
        stock_path[t] = stock_path[t - 1] * np.exp((mu - 0.5 * sigma ** 2) * dt + sigma * np.sqrt(dt) * Z)
    return stock_path, times


def evaluate_agent(agent, env):
    """
    Runs one evaluation episode and logs:
      - Stock prices,
      - Times,
      - PDE convertible bond prices,
      - Conversion values,
      - Agent decisions.
    """
    state = env.reset()
    done = False
    records = {"stock_prices": [], "times": [], "pde_prices": [], "conversion_values": [], "decisions": []}
    while not done:
        S, t, pde_price = state
        conv_value = (S / env.engine.K) * env.engine.par
        action = agent.select_action(state)
        records["stock_prices"].append(S)
        records["times"].append(t)
        records["pde_prices"].append(pde_price)
        records["conversion_values"].append(conv_value)
        records["decisions"].append(action)
        state, _, done, _ = env.step(action)
    return records


def visualize_results(records):
    """
    Generates comparative visualizations:
      - Stock price path with RL conversion decisions.
      - PDE price vs. conversion value over time.
    """
    times = np.array(records["times"])
    stock_prices = np.array(records["stock_prices"])
    pde_prices = np.array(records["pde_prices"])
    conv_values = np.array(records["conversion_values"])
    decisions = np.array(records["decisions"])

    plt.figure(figsize=(12, 6))
    # Plot stock prices and mark conversion decisions.
    plt.subplot(2, 1, 1)
    plt.plot(times, stock_prices, label="Stock Price", color="blue")
    convert_mask = decisions == 1
    plt.scatter(times[convert_mask], stock_prices[convert_mask], color="red", marker="x", s=50, label="Convert")
    plt.xlabel("Time")
    plt.ylabel("Stock Price")
    plt.title("Stock Price Path with RL Conversion Decisions")
    plt.legend()

    # Plot PDE price and conversion value.
    plt.subplot(2, 1, 2)
    plt.plot(times, pde_prices, label="PDE Price", color="green")
    plt.plot(times, conv_values, label="Conversion Value", color="orange", linestyle="--")
    plt.xlabel("Time")
    plt.ylabel("Price")
    plt.title("PDE-based CB Price vs. Conversion Value")
    plt.legend()
    plt.tight_layout()
    plt.show()


def main():
    # Parameters for GBM simulation.
    S0 = 100.0
    mu = 0.05
    sigma = 0.20
    T = 1.0
    num_steps = 15000  # Approximately 15K records.
    stock_path, times = generate_gbm_stock_path(S0, mu, sigma, T, num_steps)
    print("Synthetic GBM stock path generated.")

    # Initialize PDE engine with the same parameters as during RL training.
    engine = TsiveriotisFernandesEngine(
        S0=S0, K=100.0, r=0.05, sigma=sigma, T=T,
        q=0.0, spread=0.01, M=100, N=100, par=100.0, early_exercise=True
    )
    env = ConvertibleBondEnvTF(engine, stock_path, times)

    # Load pre-trained RL agent.
    agent = PolicyGradientAgent(input_dim=3, hidden_dim=32, output_dim=2, lr=1e-3, gamma=0.99)
    agent.load_model("policy_model.pth")

    records = evaluate_agent(agent, env)
    print("Evaluation complete. Visualizing results...")
    visualize_results(records)


if __name__ == "__main__":
    main()
